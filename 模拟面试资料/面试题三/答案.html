<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .container {
            text-decoration: underline solid;
            text-align: center;
        }

        .container>div {
            color: #00f !important;
        }

        .box {
            width: 100px;
            height: 100px;
            background-color: #f00;
        }
    </style>
</head>

<body>
    <!-- <div class="container">
        hello
        <div style="color: #f00;">
            world
        </div>
    </div>

    <div class="container2">
        <button class="btn1">btn1</button>
        <button class="btn2">btn2</button>
        <button class="btn3">btn3</button>
    </div> -->

    <div>
        <div class="box" style="float: left;"></div>
        <div style="height: 100px;"></div>
    </div>
    <div class="box" style="background: #ff0"></div>
</body>
<script>
    // 4. 浏览器解析元素时，将元素分为了 content内容 + padding内边距 + border边框 + margin外边距 这几个部分
    // 这四个部分合起来称为盒子模型


    // 5. 谈谈 flex 布局和 grid 布局
    // flex 布局
    // flex 布局可以排列一个父元素下的子元素
    // 按照主要轴和交叉轴进行排列

    // grid 布局
    // grid 是一种网格布局，它的特点是按照行列布局


    // 6.
    // rem 1rem=html节点上一个字符的宽度
    // cm 厘米
    // vh 相对于视口的高度
    // px 绝对像素大小

    // 8.
    // 哪些属性可以被继承
    // color
    // fontFamily font-size font-weight 等等 字体相关属性
    // 文本相关属性 text-decoration text-align


    // 9.
    // 隐藏页面元素的方法
    // display: none; 修改元素性质，让元素不显示，但是标签还在页面文档中
    // visibility: hidden; 修改可见度为不可见，但是元素的大小和文档流的位置保持不变
    // transform: scale(0); 缩放元素到0，元素依然存在，元素不占据位置，也没有大小 但元素性质并未改变
    // opacity: 0; 将元素透明，元素大小位置依然存在，但不改变元素性质


    // 10
    // 1. clear: both  加在浮动元素后面，缺点就是需要寻找浮动元素后面的元素来添加样式，不够直观
    // 2. 给浮动元素的父元素添加 overflow:hidden，优点是添加清除浮动的元素更加直观，哪个元素想要清空浮动对其的影响，哪个元素就添加该样式
    // 3. 添加一个不可见的占位符标签，用来撑高父元素，缺点就是麻烦，需要计算父元素原来的高度


    // 11. 输入url后敲回车发生了哪些事情
    // 1. dns 域名解析  浏览器缓存->操作系统缓存->路由器缓存->电信运营商缓存->域名根服务器
    // 2. 域名解析后得到ip，然后通过tcp/ip协议，通过ip和port找到远程主机，然后通过 http/https 协议传输数据 访问服务器
    // 3. 服务器处理请求，做出响应
    // 4. 浏览器接收服务器的响应
    // 5. 渲染浏览器的窗口



    // 13
    // var: 定义变量，可以重复定义，且不具备块级作用域
    // let: 定义变量, 不能重复定义，具备块级作用域
    // const: 定义常量, 定义后不能修改其值，具备块级作用域

    let sex = 'male'
    if (sex === 'male') {
        // const a = 1
        // let b = 2
        var c = 3
    }

    // console.log(a);
    // console.log(b);
    console.log(c);



    // 17
    // 通过位运算解决数字精度问题
    // 通常来说可以使用 big.js 框架来解决此问题 new Big('0.1').add('0.2')


    let a = 1 // 000001
    // 5 => 000101
    console.log(a & 5);
    console.log(a | 5);
    console.log(~a);
    a = 4
    // 000100
    // 010000
    // 000001
    console.log(a << 2);
    console.log(a >> 2);



    // 18
    // js内存包含3个部分
    // 堆 栈 任务队列
    // 内存泄漏的情况有哪些? 只要让 堆 栈 任务队列 满出来就可以了

    // 堆满堆，因为堆上存的是对象的数据，所以创建足够多的对象后 堆可以被堆满
    // while (true) {
    //     setTimeout(() => {
    //         window[Date.now()] = {name: '张三'}
    //     }, 0)
    // }

    // 堆满栈，因为栈上存的是函数调用的数据，所以只要重复调用函数不返回，就能堆满栈
    // function fn() {
    //     fn()
    // }

    // fn()

    // 堆满任务队列，因为任务队列中存放的是宏任务和微任务的数据，所以只要不停的创建不会结束的宏任务或微任务就能堆满队列


    // 20.
    // 下拉刷新: 捕获页面容器在顶部(offsetTop==0)时，下拉的事件 mousedown 记录鼠标 y 坐标   mouseup 记录鼠标y坐标，对比坐标是否下移
    // 上拉加载: 判断容器是否已经触底了 offsetTop >= content.height - window.innerHeight


    // 21.
    // ajax 异步网络请求
    // axios 是 http client （http客户端） 用于发起http协议请求的工具
    // jsonp 是解决跨域问题的一种服务端协议 jsonp 原理就是利用 script 标签不受跨域影响来实现的


    // 22.
    // 事件委托优缺点
    // 优点: 父元素可以统一捕获子元素的事件
    // 缺点: 统一捕获多个子元素事件时，不方便区分事件的发出源头


    let container2 = document.querySelector('.container2')
    let btn1 = document.querySelector('.btn1')

    container2.addEventListener('click', ev => {
        console.log(ev);
    })


    // 23.
    // 为了达到响应式更新页面并且减少页面更新的性能开销，所以使用虚拟文档

    // 25.
    // key的作用：让虚拟节点的顺序和真实节点的顺序保持一致
    // 为什么不用index: 因为数组成员的索引是会变化的



    // 26.
    // beforeEach 进入每个页面前
    // beforeAfter 进入每个页面后
    // resolveEach 进入页面前，且在 组件的守卫函数执行前


    // 27.
    // vue 的响应式设计受到 mvvm 设计模式的启发，(解释一下mvvm的图)
    // 响应式设计原理为... （解释一下响应式设计原理图）



    // 28.
    // vue.js 通过 vnode 来声明页面元素，vnode 在挂载的时候，会被转换成 dom 元素，在转换成 dom 元素后，vue 会给添加了 v-on 指令的元素 通过 addEventListener 绑定事件

    // 29.
    // .prevent .stop .once

    // 31
    // 顺序如下
    // p 代表父组件生命周期 c 代表子组件生命周期
    // p setup
    // p beforeCreate
    // p created
    // p beforeMount
    // c setup
    // c beforeCreate
    // c created
    // c beforeMount
    // c mounted
    // p mounted


    // 32
    // 此题回答vuex的原理图即可
    // 注意: vuex 存储的内容是保存在内存中的，所以一旦刷新页面，数据将被重置

    // 34
    // <img src="abc" onerror="alert('ok')"/>


    // 35
    // 1. 给服务器添加跨域响应头
    //   access-control-allow-origin: *
    //   access-control-allow-methods: *
    //   access-control-allow-headers: *

    // 2. 使用jsonp跨域
    // 例如当前页面是 http://127.0.0.1:80 要访问 http://127.0.0.1:1024
    // 那么在 http://127.0.0.1:80 中 使用 script 标签 例如: <script src="http://127.0.0.1:1024/testApi?callback=myCallback"></_script>(script 请求只能是get请求)
    // 服务器将返回如下类似内容: myCallback(data)

    function myCallback(data) {
        // 此处的data就是服务器返回的数据
    }

    // 3. 反向代理服务器

    // 36.
    // promise 的内容会在异步进程中执行，然后将回调函数放到主进程的微任务队列中，当队列执行到头部的时候，执行 promise 的 resolve 回调，然后触发 then

    // 37.
    // 闭包是一个封闭的内存空间，直到程序结束时才会释放内存
    // 应用场景
    // 封装模块
    // 封装函数
    // 避免名称冲突


    // 38
    // undefined string boolean number object function bigint symbol



    // 39
    // 强转
    // Number('123') Boolean(0) String(234)
    // 隐式转换
    // 123 + ''  '' == 0   '123' - 123



    // 40
    // vue2:
    //      1. 性能相比存在组合式API的vue3，更低
    //      2. vue2 有过滤器 filter
    //      3. Vue.set()  this.$set() 声明响应式属性
    //      4. 事件修饰符存在 .native 作用是：若组件存在一个 click 事件 那么若写成 <Component @click.native="someFunction"> 那么 someFunction函数最终将绑定到组件的根节点上
    //      5. 组件只能有一个根节点
    // vue3:
    //      1. 有组合式API 提升了框架的性能
    //      2. filter 被删除了
    //      3. ref() 来声明响应式属性
    //      4. .native 被删除了
    //      5. 组件可以有多个根节点
    // 总结:
    // vue3 比 vue2 优化了很多性能
    // vue3 比 vue2 书写起来更方便，且提供了更多扩展的内容 例如:给组件添加多个根节点，添加 组合式API




    // 41.
    // 1. xss 注入漏洞: 不要让用户写的内容直接编译成html代码，否则就会遇到注入漏洞 例如:vue的 v-html
    // 2. 注意参数校验，因为用户输入的内容可能是非法参数从而影响数据安全或给服务器添加不必要的脏数据
</script>

</html>