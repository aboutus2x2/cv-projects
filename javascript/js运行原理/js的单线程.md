# js的单线程

在很多文档和网络资料中都会提到 `js` 是单线程的，所以需要理解到底这个说法指的是什么

## 多线程

要将单线程，就来对比看看多线程。以经典的多线程语言 `java` 为例，假设 `java`  中定义一个方法，那么作为多线程语言，`java` 允许同一时间由多个线程同时调用同一个 `java` 文件上的同一个方法，上述这种行为就是多线程异步调用。这种多线程异步的应用场景中，最容易出现的问题就是线程不安全问题

### 线程安全

假设有个变量 `num` 存放了一个数字 `0`

现在我们假设有三个线程 `t1 t2 t3`

接下来三个线程同时读取 `num` 的值并试图让其自增 `1`

首先我们期望的结果是：三个线程能分别对 `num` 执行加一的操作，最后得到 `num` 为 `3` 的结果

但实际是由于三个线程是同时运行的，那么当 `t1 t2 t3` 同时读取 `num` 值的时候，他们都读出了 `0` 这个值，然后自增后重新赋值给 `num` 后，`num` 最终的值都被赋值成了 `1`

所以在这个例子中，用于存储数据的变量 `num` 我们称它是 `线程不安全` 的

## js的单线程

`js` 的代码执行时，在一个应用中不允许多个线程同时使用并执行同一文件中的代码，所以他是单线程的

那么 `js` 是单线程的，为什么还能运行异步的代码？原因是执行 `js` 的浏览器，或者 `Node.js` 都支持异步 api，实际上现代浏览器和 `Node.js` 都可以创建子进程，但都不允许开发人员直接操作线程。也有个例外，就是 `Node.js` 允许操作进程，但浏览器不行。

> 注意：此处要明确进程和线程的区别

## js的线程安全

首先看看以下代码

```js
let a = 0

setTimeout(() => {
    a = a + 1
}, 1000)

setTimeout(() => {
    a = a + 1
}, 1000)

setTimeout(() => {
    a = a + 1
}, 1000)
```

似乎上述代码在1秒后同时为变量 `a` 赋值，运行看看结果 `a` 的值是多少？

和 `java` 不同 `js` 运行异步 api `setTimeout` 后，`a` 的值是 `3`

> 原因：`setTimeout` 和 `setInterval` 这两个异步 api 确实会新建一个异步的线程进行计时，但是最终参数的回调函数，都会回到主线程中进行调用。也就是说上述代码的三个 `setTimeout` 是`同时`计时，但在主线程中`依序`调用回调函数（此处的`依序`的顺序是未知的，不能简单理解成从上到下执行）

所以最后的结论就是：`js` 是单线程运行的且线程安全的

可以试试以下代码来看看效果：

```js
setTimeout(() => {
    debugger
    console.log('a')
}, 1000)

setTimeout(() => {
    // 1 秒后，此处代码会由于循环次数过多，会导致运行卡顿
    // 此时通过debugger，可以发现另外的 setTimeout 回调函数进入了等待而并未执行
    for(let i = 0; i < 1000000; i++){
        console.log(i)
    }
    console.log('b')
}, 1000)

setTimeout(() => {
    debugger
    console.log('c')
}, 1000)
```
